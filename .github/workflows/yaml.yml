name: "üîÑ Manuten√ß√£o Unificada (Playlists + Limpeza + Deploy)"

on:
  schedule:
    - cron: '0 3 * * *'  # Diariamente √†s 00:00 BRT - Playlists
    - cron: '0 15 * * *'  # 12:00 BRT - Limpeza de arquivos
    - cron: '1 */8 * * *' # A cada 8 horas - Limpeza de execu√ß√µes
    - cron: '25 10 * * *' # 07:25 BRT - Deploy
  workflow_dispatch:
    inputs:
      force_operation:
        description: 'For√ßar opera√ß√£o espec√≠fica'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - playlists
          - cleanup_files
          - cleanup_runs
          - deploy

env:
  TZ: America/Fortaleza
  PYTHONUNBUFFERED: 1
  PIP_CACHE_DIR: /tmp/pip-cache

permissions:
  contents: write
  actions: write
  pages: write
  id-token: write

jobs:
  # ‚úÖ 1. JOB: Processamento de Playlists (OTIMIZADO)
  process-playlists:
    name: "üì• Processar Playlists"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    if: >-
      github.event.inputs.force_operation == 'all' ||
      github.event.inputs.force_operation == 'playlists' ||
      (github.event_name == 'schedule' && github.event.schedule == '0 3 * * *')
    
    steps:
      - name: "üîΩ Checkout Otimizado"
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: 1
          sparse-checkout: |
            *.py
            *.m3u
            *.xml.gz
            requirements.txt

      - name: "üêç Configurar Python com Cache"
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'
          cache-dependency-path: '**/requirements.txt'

      - name: "‚öôÔ∏è Instalar Depend√™ncias R√°pido"
        run: |
          pip install --cache-dir /tmp/pip-cache --upgrade pip
          pip install --cache-dir /tmp/pip-cache --no-cache-dir requests beautifulsoup4 aiohttp asyncio

      - name: "‚ñ∂Ô∏è Executar Scripts em Paralelo"
        run: |
          # Fun√ß√£o para executar script com timeout e logging
          run_script() {
            local script=$1
            local timeout=300
            echo "üïê Executando $script (timeout: ${timeout}s)"
            
            if timeout $timeout python "$script"; then
              echo "‚úÖ $script conclu√≠do com sucesso"
              return 0
            else
              echo "‚ö†Ô∏è $script falhou ou atingiu timeout"
              return 1
            fi
          }
          
          # Executar scripts principais
          run_script "playlists.py" &
          # run_script "playlists2.py" &  # Descomente se necess√°rio
          # run_script "Playlist.py" &    # Descomente se necess√°rio
          
          # Aguardar conclus√£o de todos
          wait
          echo "üéØ Todos os scripts de playlist finalizados"

      - name: "‚è±Ô∏è Adicionar Timestamp Eficiente"
        run: |
          timestamp=$(TZ='America/Fortaleza' date '+%d/%m/%Y - %H:%M:%S')
          export timestamp
          
          # Processar arquivos em lote
          find . -maxdepth 1 -type f \( -name "*.m3u" -o -name "*.xml.gz" \) -print0 | \
          xargs -0 -P 4 -I {} sh -c '
            echo -e "\n\n# Atualizado em $timestamp BRT" >> "$1"
            echo "üìù Timestamp adicionado: $1"
          ' _ {}

      - name: "üíæ Commit R√°pido das Altera√ß√µes"
        if: success()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global pull.rebase false
          
          # Verificar mudan√ßas de forma eficiente
          changed_files=$(git status --porcelain | wc -l)
          
          if [ "$changed_files" -gt 0 ]; then
            echo "üì¶ $changed_files arquivos modificados"
            git add -A
            git commit -m "üîÑ Atualiza√ß√£o autom√°tica das playlists $(TZ='America/Fortaleza' date '+%d/%m %H:%M')"
            
            # Pull com estrat√©gia de fallback
            git pull origin main --no-edit --strategy-option=theirs || true
            
            # Push com retry
            for i in 1 2 3; do
              if git push "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git" main; then
                echo "‚úÖ Push realizado com sucesso"
                break
              else
                echo "üîÑ Tentativa $i falhou, aguardando..."
                sleep 5
              fi
            done
          else
            echo "‚úÖ Nenhuma altera√ß√£o detectada"
          fi

  # ‚úÖ 2. JOB: Limpeza de Arquivos (OTIMIZADO)
  cleanup-files:
    name: "üóëÔ∏è Limpar Arquivos Tempor√°rios"
    runs-on: ubuntu-latest
    needs: process-playlists
    timeout-minutes: 10
    
    if: >-
      github.event.inputs.force_operation == 'all' ||
      github.event.inputs.force_operation == 'cleanup_files' ||
      (github.event_name == 'schedule' && github.event.schedule == '0 15 * * *')
    
    steps:
      - name: "üîΩ Checkout R√°pido"
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            *
            !.git

      - name: "üóëÔ∏è Limpeza Eficiente de Arquivos"
        run: |
          # Arquivos essenciais para manter
          declare -A keep_files=(
            ["README.md"]=1 [".gitignore"]=1 ["index.html"]=1
            ["script.js"]=1 ["style.css"]=1 ["deploy.py"]=1
            ["playlists.py"]=1 ["playlists2.py"]=1 ["Playlist.py"]=1
            ["downloads_files.py"]=1 ["generate_metadata.js"]=1 
            ["files_metadata.json"]=1 [".github"]=1
          )
          
          # Padr√µes para deletar (mais espec√≠ficos primeiro)
          patterns=(
            "coroa_vidaloka-*.mp4"
            "majormarra-*.mp4" 
            "marinahelenabr-*.jpg"
            "*-*-*.jpg" "*-*-*.mp4" "*-*-*.png"
            "temp_*.txt" "*.tmp" "*.temp"
          )
          
          echo "üîç Iniciando limpeza eficiente..."
          total_freed=0
          deleted_count=0
          
          # Fun√ß√£o para verificar se deve manter
          should_keep() {
            local file="$1"
            [[ -n "${keep_files[$file]}" ]] && return 0
            [[ "$file" == *.github/* ]] && return 0
            [[ "$file" == .github/* ]] && return 0
            return 1
          }
          
          # Processar padr√µes em paralelo quando poss√≠vel
          for pattern in "${patterns[@]}"; do
            while IFS= read -r -d '' file; do
              filename=$(basename "$file")
              
              if ! should_keep "$filename" && [[ -f "$file" ]]; then
                file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
                if rm -f "$file"; then
                  echo "üóëÔ∏è Deletado: $file ($((file_size/1024)) KB)"
                  ((total_freed += file_size))
                  ((deleted_count++))
                fi
              fi
            done < <(find . -name "$pattern" -type f -print0 2>/dev/null || true)
          done
          
          echo "üìä Resumo da limpeza:"
          echo "   üìÅ Arquivos deletados: $deleted_count"
          echo "   üíæ Espa√ßo liberado: $((total_freed/1024/1024)) MB"

      - name: "üíæ Commit da Limpeza"
        if: success()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          if git diff-index --quiet HEAD --; then
            echo "‚úÖ Nenhum arquivo para limpar"
          else
            git add -A
            git commit -m "üßπ Limpeza de arquivos tempor√°rios - $(TZ='America/Fortaleza' date '+%d/%m %H:%M')"
            
            # Push direto e r√°pido
            git push "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git" main
            echo "‚úÖ Limpeza commitada com sucesso"
          fi

  # ‚úÖ 3. JOB: Limpeza de Execu√ß√µes (SUPER OTIMIZADO)
  cleanup-runs:
    name: "üßπ Limpar Execu√ß√µes Antigas"
    runs-on: ubuntu-latest
    needs: cleanup-files
    timeout-minutes: 5
    
    if: >-
      github.event.inputs.force_operation == 'all' ||
      github.event.inputs.force_operation == 'cleanup_runs' ||
      (github.event_name == 'schedule' && startsWith(github.event.schedule, '1 */8'))
    
    steps:
      - name: "üóëÔ∏è Limpeza R√°pida de Execu√ß√µes"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          echo "üöÄ Iniciando limpeza otimizada de execu√ß√µes..."
          
          # Configura√ß√µes
          WORKFLOW_NAME="üîÑ Manuten√ß√£o Unificada (Playlists + Limpeza + Deploy)"
          KEEP_RUNS=5  # Manter as √∫ltimas 5 execu√ß√µes
          BATCH_SIZE=10
          
          # Obter workflow ID de forma eficiente
          echo "üìã Obtendo ID do workflow..."
          WORKFLOW_JSON=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows")
          
          WORKFLOW_ID=$(echo "$WORKFLOW_JSON" | jq -r --arg name "$WORKFLOW_NAME" '.workflows[] | select(.name == $name) | .id')
          
          if [[ -z "$WORKFLOW_ID" || "$WORKFLOW_ID" == "null" ]]; then
            echo "‚ùå Workflow n√£o encontrado: $WORKFLOW_NAME"
            exit 1
          fi
          
          echo "üéØ Workflow ID: $WORKFLOW_ID"
          
          # Obter execu√ß√µes antigas (exceto as √∫ltimas KEEP_RUNS)
          echo "üîç Buscando execu√ß√µes para limpar..."
          RUNS_JSON=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/$WORKFLOW_ID/runs?per_page=100&status=completed")
          
          # Extrair IDs das execu√ß√µes antigas
          OLD_RUN_IDS=$(echo "$RUNS_JSON" | jq -r ".workflow_runs[$KEEP_RUNS:] | .[] | select(.status == \"completed\") | .id")
          
          if [[ -z "$OLD_RUN_IDS" ]]; then
            echo "‚úÖ Nenhuma execu√ß√£o antiga para limpar"
            exit 0
          fi
          
          RUN_COUNT=$(echo "$OLD_RUN_IDS" | wc -l | tr -d ' ')
          echo "üóëÔ∏è Encontradas $RUN_COUNT execu√ß√µes para limpar"
          
          # Deletar em lotes para melhor performance
          counter=0
          batch=()
          
          delete_batch() {
            local batch_ids=("$@")
            local deleted_in_batch=0
            
            for run_id in "${batch_ids[@]}"; do
              if [[ -n "$run_id" ]]; then
                response_code=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
                  -H "Authorization: token $GITHUB_TOKEN" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/${{ github.repository }}/actions/runs/$run_id")
                
                if [[ "$response_code" == "204" ]]; then
                  echo "‚úÖ Deletado: $run_id"
                  ((deleted_in_batch++))
                  ((counter++))
                else
                  echo "‚ö†Ô∏è Falha em $run_id (HTTP $response_code)"
                fi
                
                # Pequena pausa para evitar rate limiting
                sleep 0.5
              fi
            done
            
            echo "üì¶ Lote processado: $deleted_in_batch execu√ß√µes deletadas"
          }
          
          # Processar em lotes
          while IFS= read -r run_id; do
            batch+=("$run_id")
            
            if [[ ${#batch[@]} -ge $BATCH_SIZE ]]; then
              delete_batch "${batch[@]}"
              batch=()
            fi
          done <<< "$OLD_RUN_IDS"
          
          # Processar √∫ltimo lote
          if [[ ${#batch[@]} -gt 0 ]]; then
            delete_batch "${batch[@]}"
          fi
          
          echo "üéâ Limpeza finalizada: $counter execu√ß√µes removidas"

  # ‚úÖ 4. JOB: Deploy para GitHub Pages (OTIMIZADO)
  deploy-pages:
    name: "üöÄ Deploy GitHub Pages"
    runs-on: ubuntu-latest
    needs: cleanup-runs
    timeout-minutes: 8
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    
    if: >-
      github.event.inputs.force_operation == 'all' ||
      github.event.inputs.force_operation == 'deploy' ||
      (github.event_name == 'schedule' && github.event.schedule == '25 10 * * *')
    
    steps:
      - name: "üîΩ Checkout para Deploy"
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: "üèóÔ∏è Configura√ß√£o R√°pida do Pages"
        uses: actions/configure-pages@v4
        with:
          enablement: true

      - name: "üì¶ Upload Otimizado do Artifact"
        uses: actions/upload-pages-artifact@v3
        with:
          path: .
          exclude-assets: |
            *.py
            *.sh
            .github/workflows/*
            scripts/
            *.tmp
            *.temp
          retention-days: 1

      - name: "üöÄ Deploy com Retry"
        id: deployment
        uses: actions/deploy-pages@v4
        with:
          timeout: 60000
          error-count: 3

      - name: "üìä Status do Deploy"
        run: |
          if [[ "${{ steps.deployment.outcome }}" == "success" ]]; then
            echo "üéâ Deploy realizado com sucesso!"
            echo "üåê URL: ${{ steps.deployment.outputs.page_url }}"
          else
            echo "‚ùå Deploy falhou"
            exit 1
          fi

  # ‚úÖ 5. JOB: Relat√≥rio Final (NOVO)
  report:
    name: "üìä Relat√≥rio de Execu√ß√£o"
    runs-on: ubuntu-latest
    needs: [process-playlists, cleanup-files, cleanup-runs, deploy-pages]
    if: always()
    
    steps:
      - name: "üìà Gerar Relat√≥rio"
        run: |
          echo "üìä RELAT√ìRIO DA MANUTEN√á√ÉO UNIFICADA"
          echo "======================================"
          echo "üïê Timestamp: $(TZ='America/Fortaleza' date '+%d/%m/%Y %H:%M:%S BRT')"
          echo "üîß Workflow: ${{ github.workflow }}"
          echo "üéØ Trigger: ${{ github.event_name }}"
          echo ""
          echo "üìã STATUS DOS JOBS:"
          echo "-------------------"
          echo "üì• Playlists: ${{ needs.process-playlists.result }}"
          echo "üóëÔ∏è Limpeza Arquivos: ${{ needs.cleanup-files.result }}"
          echo "üßπ Limpeza Execu√ß√µes: ${{ needs.cleanup-runs.result }}"
          echo "üöÄ Deploy Pages: ${{ needs.deploy-pages.result }}"
          echo ""
          
          if [[ "${{ needs.process-playlists.result }}" == "success" && \
                "${{ needs.cleanup-files.result }}" == "success" && \
                "${{ needs.cleanup-runs.result }}" == "success" && \
                "${{ needs.deploy-pages.result }}" == "success" ]]; then
            echo "‚úÖ TODAS AS OPERA√á√ïES CONCLU√çDAS COM SUCESSO"
            echo "üéØ Sistema otimizado e atualizado"
          else
            echo "‚ö†Ô∏è ALGUMAS OPERA√á√ïES ENCONTRARAM PROBLEMAS"
            echo "üìù Verifique os logs para detalhes"
          fi
