# ARQUIVO: .github/workflows/optimized-unified.yml
name: "üîÑ Workflow Otimizado Unificado"

on:
  schedule:
    - cron: '0 3 * * *'      # Playlists - 00:00 BRT
    - cron: '0 15 * * *'     # Limpeza arquivos - 12:00 BRT  
    - cron: '1 */12 * * *'   # Limpeza execu√ß√µes - a cada 12h
    - cron: '25 10 * * *'    # Deploy - 07:25 BRT
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      action_type:
        description: 'Tipo de a√ß√£o a executar'
        required: false
        default: 'all'
        type: choice
        options:
        - all
        - playlists_only
        - cleanup_only
        - deploy_only

env:
  TZ: America/Fortaleza
  PYTHON_VERSION: '3.10'
  NODE_VERSION: '18'

permissions:
  contents: write
  actions: write
  pages: write
  id-token: write

jobs:
  # JOB 1: Configura√ß√£o e Cache
  setup:
    name: "‚öôÔ∏è Configura√ß√£o Inicial"
    runs-on: ubuntu-latest
    outputs:
      python-cache-hit: ${{ steps.python-cache.outputs.cache-hit }}
      node-cache-hit: ${{ steps.node-cache.outputs.cache-hit }}
    
    steps:
      - name: "üîΩ Checkout do reposit√≥rio"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "üêç Configurar Python com Cache"
        id: python-cache
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: "üì¶ Cache Python Dependencies"
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            ~/.local/bin
          key: ${{ runner.os }}-python-${{ hashFiles('**/requirements.txt', '**/deployment.py', '**/playlists.py') }}
          restore-keys: |
            ${{ runner.os }}-python-

      - name: "üõ†Ô∏è Configurar Node.js com Cache"
        id: node-cache
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'  # Agora funcionar√° com package.json

      - name: "üì¶ Cache Node Dependencies"
        uses: actions/cache@v3
        with:
          path: |
            ~/.npm
            node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package.json', '**/generate_metadata.js') }}
          restore-keys: |
            ${{ runner.os }}-node-

  # JOB 2: Processamento de Playlists
  process-playlists:
    name: "üì• Processar Playlists"
    runs-on: ubuntu-latest
    needs: setup
    if: |
      github.event.inputs.action_type == 'all' ||
      github.event.inputs.action_type == 'playlists_only' ||
      github.event_name == 'schedule'
    
    steps:
      - name: "üîΩ Checkout do reposit√≥rio"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "üêç Restaurar Cache Python"
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            ~/.local/bin
          key: ${{ runner.os }}-python-${{ hashFiles('**/requirements.txt', '**/deployment.py', '**/playlists.py') }}

      - name: "‚öôÔ∏è Instalar depend√™ncias Python"
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 lxml urllib3

      - name: "üîç Verificar scripts dispon√≠veis"
        run: |
          echo "üìÅ Scripts Python encontrados:"
          find . -name "*.py" -type f | grep -v "__pycache__" || echo "Nenhum script Python encontrado"

      - name: "‚ñ∂Ô∏è Executar scripts de playlists com fallback"
        run: |
          set -e
          echo "üöÄ Executando scripts de playlists..."
          
          # Tentativa hier√°rquica de execu√ß√£o
          if [ -f "playlists.py" ]; then
            echo "üìÑ Executando playlists.py..."
            python playlists.py
          elif [ -f "deployment.py" ]; then
            echo "üìÑ Executando deployment.py..."
            python deployment.py
          elif [ -f "playlist_manager.py" ]; then
            echo "üìÑ Executando playlist_manager.py..."
            python playlist_manager.py
          else
            echo "‚ö†Ô∏è Nenhum script de playlist encontrado. Criando exemplo..."
            # Criar script exemplo se n√£o existir
            cat > example_playlist.py << 'EOF'
#!/usr/bin/env python3
print("üìã Script de exemplo para playlists")
print("‚úÖ Adicione seus scripts Python aqui")
with open("example.m3u", "w") as f:
    f.write("#EXTM3U\n#EXTVLCOPT:network-caching=1000\n")
print("üìÅ Arquivo exemplo criado: example.m3u")
EOF
            python example_playlist.py
          fi

      - name: "‚è±Ô∏è Adicionar timestamp nos arquivos"
        run: |
          echo "üïí Adicionando timestamp..."
          timestamp=$(TZ='America/Fortaleza' date '+%d/%m/%Y - %H:%M:%S BRT')
          
          for ext in m3u xml xml.gz txt log; do
            for file in *.$ext; do
              if [ -f "$file" ]; then
                echo -e "\n# Atualizado em $timestamp" >> "$file"
                echo "‚úÖ Timestamp adicionado: $file"
              fi
            done
          done

      - name: "üìä Verificar arquivos gerados"
        run: |
          echo "üìÅ Conte√∫do do diret√≥rio:"
          ls -la
          echo ""
          echo "üìä Estat√≠sticas de arquivos:"
          find . -maxdepth 1 -type f -name "*.m3u" -o -name "*.xml" -o -name "*.xml.gz" | wc -l | xargs echo "Total de arquivos de playlist:"

      - name: "üíæ Commit das altera√ß√µes"
        if: success()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Estrat√©gia robusta de commit
          git fetch origin main
          git pull --rebase origin main || git merge --allow-unrelated-histories origin/main
          
          if git status --porcelain | grep -q .; then
            echo "üìù Altera√ß√µes detectadas, fazendo commit..."
            git add .
            git commit -m "üîÑ Atualiza√ß√£o autom√°tica - $(TZ='America/Fortaleza' date '+%d/%m/%Y %H:%M')"
            git push origin main
            echo "‚úÖ Altera√ß√µes commitadas com sucesso."
          else
            echo "‚úÖ Nenhuma altera√ß√£o detectada."
          fi

  # JOB 3: Gera√ß√£o de Metadados
  generate-metadata:
    name: "üìä Gerar Metadados"
    runs-on: ubuntu-latest
    needs: [setup, process-playlists]
    
    steps:
      - name: "üîΩ Checkout do reposit√≥rio"
        uses: actions/checkout@v4

      - name: "üõ†Ô∏è Restaurar Cache Node.js"
        uses: actions/cache@v3
        with:
          path: |
            ~/.npm
            node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package.json', '**/generate_metadata.js') }}

      - name: "üìÑ Gerar metadados"
        run: |
          if [ -f "generate_metadata.js" ]; then
            echo "üöÄ Executando generate_metadata.js..."
            node generate_metadata.js
          else
            echo "üìù Criando generate_metadata.js b√°sico..."
            cat > generate_metadata.js << 'EOF'
const fs = require('fs');
const { execSync } = require('child_process');

console.log('üìä Gerando metadados...');

try {
  const files = fs.readdirSync('.');
  const playlists = files.filter(f => f.endsWith('.m3u') || f.endsWith('.xml'));
  
  const metadata = {
    generated: new Date().toISOString(),
    timezone: 'America/Fortaleza',
    files: playlists.map(file => {
      const stat = fs.statSync(file);
      return {
        name: file,
        size: stat.size,
        modified: stat.mtime
      };
    }),
    summary: {
      total_files: playlists.length,
      total_size: playlists.reduce((sum, file) => sum + fs.statSync(file).size, 0)
    }
  };
  
  fs.writeFileSync('metadata.json', JSON.stringify(metadata, null, 2));
  console.log('‚úÖ metadata.json gerado com sucesso!');
  
  // Criar HTML simples
  const html = `<!DOCTYPE html>
<html>
<head><title>Playlists</title></head>
<body>
  <h1>Playlists Dispon√≠veis</h1>
  <ul>${playlists.map(f => `<li><a href="${f}">${f}</a></li>`).join('')}</ul>
  <p>Atualizado: ${new Date().toLocaleString('pt-BR')}</p>
</body>
</html>`;
  
  fs.writeFileSync('index.html', html);
  console.log('‚úÖ index.html gerado com sucesso!');
  
} catch (error) {
  console.error('‚ùå Erro:', error);
}
EOF
            node generate_metadata.js
          fi

  # JOB 4: Deploy para GitHub Pages
  deploy:
    name: "üöÄ Deploy GitHub Pages"
    runs-on: ubuntu-latest
    needs: [process-playlists, generate-metadata]
    if: |
      github.event.inputs.action_type == 'all' ||
      github.event.inputs.action_type == 'deploy_only' ||
      (github.event_name == 'schedule' && github.event.schedule == '25 10 * * *') ||
      github.event_name == 'push'
    
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    
    steps:
      - name: "üîΩ Checkout do reposit√≥rio"
        uses: actions/checkout@v4

      - name: "üèóÔ∏è Preparar arquivos para deploy"
        run: |
          echo "üìÅ Preparando arquivos para deploy..."
          mkdir -p public
          
          # Copiar arquivos relevantes
          cp -f *.html *.json *.m3u *.xml *.xml.gz *.js public/ 2>/dev/null || true
          
          # Criar README se n√£o existir
          if [ ! -f "public/README.md" ]; then
            cat > public/README.md << 'EOF'
# Playlists IPTV

Arquivos gerados automaticamente via GitHub Actions.

- **Atualizado em**: $(date)
- **Playlists dispon√≠veis**: $(ls -1 public/*.m3u 2>/dev/null | wc -l || echo 0)

## Como usar

Adicione as URLs dos arquivos .m3u no seu player IPTV favorito.
EOF
          fi
          
          echo "üìä Conte√∫do do diret√≥rio public:"
          ls -la public/ || echo "‚ö†Ô∏è Diret√≥rio public vazio"

      - name: "üöÄ Deploy no GitHub Pages"
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./public
          publish_branch: gh-pages
          force_orphan: true
          user_name: 'github-actions[bot]'
          user_email: 'github-actions[bot]@users.noreply.github.com'

  # JOB 5: Limpeza (Opcional - Execu√ß√£o Separada)
  cleanup:
    name: "üßπ Limpeza"
    runs-on: ubuntu-latest
    if: |
      github.event.inputs.action_type == 'all' ||
      github.event.inputs.action_type == 'cleanup_only' ||
      github.event_name == 'schedule'
    
    permissions:
      actions: write
    
    steps:
      - name: "üóëÔ∏è Limpar execu√ß√µes antigas"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üßπ Iniciando limpeza de execu√ß√µes..."
          
          # Limpar execu√ß√µes com mais de 1 dia
          gh api -X DELETE \
            "/repos/${{ github.repository }}/actions/runs?older_than=1d" \
            --silent || echo "‚úÖ Limpeza conclu√≠da ou nenhuma execu√ß√£o para limpar"
          
          echo "üèÅ Limpeza de execu√ß√µes finalizada"
